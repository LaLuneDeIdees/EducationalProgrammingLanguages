IDEAS
написать программу показывающая весь концепт языка скомпилировать её

объявление структур и получение свойств
возможно функция тоже объект

addto with x, y, empty is {
    subto with x, y is {

    }
}
func is addto 1 2
d is func->subto 2 1

в крмпиляторе функции компиляции
(принмают параметры возрщаю двоичный код)

функции макросов

при компиляции выполнять прогу

при компиляции создать слои видимости
(всё что н первом слое константа)

потоки общаються вызываю друг у друга прерывания(прерывания останавливают поток)
прерывания прекращают поток или возращаються обратно и при этом могут создавать потоки или повторить
а также могут изменять входные параметры при продолжении

если таблица или память потоков кончается они перестают создаваться

возможно так

thread1 is thread function //create function return her interupts

thread1 123 //call interupts from thread    

--------------------------------------------------------------------------

Более полезные чистые функции принимают хотя бы один параметр.
Все полезные чистые функции должны возвращать что-нибудь.
Чистая функция всегда возвращает одинаковые значения для одинаковых входных данных.
Чистые функции не имеют побочных эффектов.
Неизменяемость
В функциональном программировании нет переменных.
addOneToSum y z =
    let
        x = 1
    in
        x + y + z
Функциональное программирование использует рекурсию для выполнения цикла.
// простой оператор цикла
var acc = 0;
for (var i = 1; i <= 10; ++i)
    acc += i;
console.log(acc); // выводит 55// без оператора цикла или переменных (рекурсия)
function sumRange(start, end, acc) {
    if (start > end)
        return acc;
    return sumRange(start + 1, end, acc + start)
}
console.log(sumRange(1, 10, 0)); // выводит 55


sumRange start end acc =
    if start > end then
        acc
    else
        sumRange (start + 1) end (acc + start)
        
    Неизменяемость делает код проще и безопаснее.












Рефакторинг
Функции высшего порядка
В функциональном программировании функция — это полноправный гражданин языка. Иными словами, функция — всего лишь другое значение.
Функции высшего порядка либо принимают функции как параметры, либо возвращают их, либо и то, и другое одновременно.
Замыкания

function grandParent(g1, g2) {
    var g3 = 3;
    return function parent(p1, p2) {
        var p3 = 33;
        return function child(c1, c2) {
            var c3 = 333;
            return g1 + g2 + g3 + p1 + p2 + p3 + c1 + c2 + c3;
        };
    };
}
grandParent имеет доступ только к своим переменным.

Замыкание — область видимости функции, которая сохраняется благодаря ссылке на эту функцию.










В функциональном программировании функции — наши строительные блоки. Мы пишем их для решения определённых задач, а потом складываем вместе, как блоки в Lego™.

Результат такого сложения называется композицией функций.


var mult5AfterAdd10 = value => mult5(add10(value));

В математике f ∘ g — композиция функций (прим. пер., или суперпозиция функций) и читается она как «применение функции f к результату функции g» или более просто «выполнение f после g». Получается, что (f ∘ g)(x) — эквивалент вызова функции f после функции g со значением x или ещё проще: f(g(x)).

add10 value =
    value + 10mult5 value =
    value * 5mult5AfterAdd10 value =
    (mult5 << add10) value


f x =
   (g << h << s << r << t) x

Бесточечная нотация — стиль описания функций без предварительного указания входных параметров. По началу такой стиль будет казаться необычным, но по мере продолжения, когда вы достаточно разберётесь, вы оцените лаконичность такого подхода.

-- Эта функция тоже ожидает 1 входной параметр 
mult5AfterAdd10 = (mult 5 << add 10)

add x y =
    x + y
mult5 value = value * 5

Как нам создать mult5AfterAdd10, используя эти две функции?

По факту, в Elm компилятор не позволит вам даже написать такой нецелесообразный код (что является одним из больших плюсов языка Elm).

Выходом из этого затруднительного положения является концепция каррирования.










Каррированная функция— это функция, принимающая один аргумент за раз.

С их помощью мы передадим в add первый параметр перед тем, как скомпонуем её с mult5. Затем, когда mult5AfterAdd10 будет вызвана, add получит свой второй параметр.

var add = x => y => x + y;

var compose = (f, g) => x => f(g(x));
var mult5AfterAdd10 = compose(mult5, add(10));

Функция компоновки (compose) получает на вход два параметра: f и g. После чего она возвращает функцию, принимающую один параметр, x, с вызовом которой композиция функций f после g осуществится с аргументом x.

Так что функция add остаётся неизменной:

add x y =
    x + y

А вот как должна была быть написана mult5AfterAdd10, возвращаясь к Части 3:

mult5AfterAdd10 =
    (mult5 << add 10)

Говоря о синтаксисе, Elm одерживает верх над такими императивными языками, как JavaScript, поскольку он изначально оптимизирован для различных задач функционального программирования, например, каррирования или композиции функций.


Каррирование и рефакторинг

generalBracket prefix suffix str =
    prefix ++ str ++ suffixbracket =
    generalBracket "{" "}"doubleBracket =
    generalBracket "{{" "}}"

Порядок входных параметров очень важен для наиболее выгодного использования каррирования.


Стандартные функции функционального программирования

for (var i = 0; i < something.length; ++i) {
    // do stuff
}

Этот код содержит одну существенную вредную особенность. И это не ошибка. Проблема в том, что это шаблонный код, то есть код, использующийся снова и снова.


Давайте возьмём этот код и положим его в функцию. Мы назовём нашу первую стандартную функцию map (прим. пер., английский глагол «наносить на карту»), так как она переносит каждое значение из старого массива в новое значение в новом массиве:

var map = (f, array) => {
    var newArray = [];    for (var i = 0; i < array.length; ++i) {
        newArray[i] = f(array[i]);
    }
    return newArray;
};

Теперь давайте напишем другую стандартную функцию, фильтрующую объекты в массиве:

var filter = (pred, array) => {
    var newArray = [];for (var i = 0; i < array.length; ++i) {
        if (pred(array[i]))
            newArray[newArray.length] = array[i];
    }
    return newArray;
};

Последняя стандартная функция называется reduce (прим. пер., английский глагол «уменьшать»). Как правило, она используется, когда надо взять список и свести его к одному значению, но, на самом деле, её возможности куда шире.

Обычно в функциональных языках эта функция носит название fold (прим. пер., английский глагол «свёртывать» или «складывать»).

var reduce = (f, start, array) => {
    var acc = start;
    for (var i = 0; i < array.length; ++i)
        acc = f(array[i], acc); // f() принимает 2 аргумента
    return acc;
});








Прозрачность ссылок (прим. пер., референциальная прозрачность или прозрачность подстановки) — выдуманный термин для описания возможности безопасной замены чистых функций их выражением. Пример наглядно продемонстрирует это.

findError key =
   "Unable to find " ++ ("'" ++ key ++ "'")

Это то, что я называю обратным рефакторингом (прим. пер., инлайнингом)(сюда я вкладываю достаточно широкий смысл) — процессом, который может использоваться программистами или программами (такими как компиляторы или приложения для тестов), чтобы более осмысленно анализировать код.


Порядок выполнения

buildMessage message value =
    let
        upperMessage =
            String.toUpper message        quotedValue =
            "'" ++ value ++ "'"    in
        upperMessage ++ ": " ++ quotedValue

Здесь buildMessage принимает message и value, затем приводит message к верхнему регистру, обрамляет value кавычками и конкатенирует эти строки, разделяя их символом двоеточия.

Заметьте, что upperMessage и quotedValue независимы друг от друга. Откуда нам известно это?

Для условия независимости есть всего две истины. Во-первых, обе функции должны быть чистыми. Это важно, поскольку при выполнении они не должны влиять друг на друга.

Если они не будут чистыми, мы никогда не сможем сказать наверняка, являются ли они независимыми. В этом случае, мы будем вынуждены ориентироваться на тот порядок выполнения, который они самостоятельно запустили. Так работают императивные языки программирования.

Во-вторых, следующее условие: результат выполнения одной функции не является входным значением другой. Если это не так, нам придётся ждать конца выполнения первой функции, чтобы запустилась вторая.

В таком ключе, upperMessage и quotedValue - обе чистые функции и ни одна из них не требует результата выполнения другой.

Следовательно, эти функции могут быть вызваны в ЛЮБОМ ПОРЯДКЕ.

Порядок выполнения кода в чистом функциональном языке программирования может быть самостоятельно определён компилятором.




Аннотация типов

Действительно, можем. Вот функция на Elm с аннотацией типов (прим. пер., сигнатурой типов):

add : Int -> Int -> Int
add x y =
    x + y

add : Int -> (Int -> Int)

Здесь говорится, что add - это функция, принимающая единственный параметр типа Int, а затем возвращающая функцию, принимающую единственный параметр Int и возвращающую Int.

Здесь говорится, что doSomething - функция, принимающая единственный параметр типа String и возвращающая функцию, которая принимает единственный параметр типа Int и возвращающая функцию, принимающую единственный параметр типа String и возвращающую String.

Заметьте, что всё получает единственный параметр. Это потому что все функции в Elm автоматически каррированные.

takes1Param : (Int -> Int) -> String
takes1Param f =
    -- do something

takes2Params - это функция, требующая два параметра, Int и другой Int. В то время как, takes1Param требует одним входным параметром функцию, принимающую Int и другой Int.

Здесь a может быть любого типа. Когда имя типа начинается с заглавной буквы, значит это явно заданный тип, например, String. Если имя типа написано в нижнем регистре, то это может быть любой тип. Здесь a может быть String, а может быть и Int.

Если вы видите (a -> a), значит имеется в виду, что входящий и выходящий типы ОБЯЗАНЫ быть одинаковыми. Не имеет значения, какие они именно, главное, чтобы они соответствовали друг другу.

Но в случае с map у нас есть (a -> b). Это означает, что хотя функция и МОЖЕТ возвращать разные типы, она также МОЖЕТ возвращать и одинаковые типы.












Ленивые вычесления

